#!/usr/bin/perl
use strict;
use Carp;

# {{{ process arguments (@ARGV)

my $printanswers = 0;
my $test_file;

my $prog_name = (split /\//, $0)[-1];  # name w/o directories
my $usage = <<"USAGE";
  USAGE:
    $prog_name -t <test file> [-a] > test.tex

  OPTIONS:
    -t     Test definition file.
    -a     Print the answers.
USAGE

for (my $i = 0; $i < @ARGV; $i++) {
	my $arg = $ARGV[$i];
	if ($arg eq '-t') {
		$test_file = $ARGV[$i + 1]
			or die "$usage\nMissing argument for '-t' option.\n";
	} elsif ($arg eq '-a') {
		$printanswers = 1;
	}
}
die "$usage\nTest file must be defined ('-t').\n" unless $test_file;

my $vals = parse_file($test_file);

my $qzt = {
	'instructions' => "",
	'class' => "",
	'term' => "",
	'title' => "",
	%$vals,
};

$qzt->{problems} = [split /\s+/, $qzt->{problems}];

# }}}

generate_tex($qzt);

# {{{ parse_file()
sub parse_file {
	my ($file) = shift;

	my %vals;

	croak "Unable to open '$file': $!" unless (open INPUT, "<", $file);

	while (my $line = <INPUT>) {

		if ($line =~ /^\[(.*)\]$/) {
			# start of block
			my $key = $1;
			my $val = '';

			while ($line = <INPUT>) {
				if ($line =~ /^\[[\/\\]$key\]$/) {
					# end of block
					chomp($val);
					last;
				} else {
					$val .= $line;
				}
			}

			$vals{$key} = $val;
		} elsif ($line =~ /(\w+)\s*\=\s*(.*)\s*/) {
			# single key/value
			chomp($2);
			$vals{$1} = $2;
		}
	}

	close INPUT;

	return \%vals;
}
# }}}

# {{{ generate_tex()

sub generate_tex {
	my ($qzt) = @_;

	print "% This file was generated by $prog_name on " . `date -R` . "\n";

	print <<'HEADER1';

%\documentclass{exam}            % w/ answers
\documentclass[noanswers]{exam}  % w/o answers

\usepackage{multicol}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{tabularx}
\usepackage{listings}
\lstset{numbers=left,
		basicstyle=\footnotesize,
		xleftmargin=0.3in}

\parindent=0pt
%\usepackage{graphicx}

\begin{document}


HEADER1

	print <<'HEADER2';
% choose one or the other,
% or leave configured by \documentclass
HEADER2
print '%' if (! $printanswers);
print '\printanswers' . "\n";
print '%' if ($printanswers);
print '\noprintanswers' . "\n";
print "\n";

my $class = $qzt->{'class'};
my $term = $qzt->{'term'};
my $title = $qzt->{'title'};
# be sure to double the escapes with double quotes!
print <<"HEADER2";

\\begin{tabularx}{\\textwidth}{l X r}
Name: \\uline{\\hspace{200pt}} & & $class \\\\
      & & $term \\\\
      & & $title \\\\
\\end{tabularx}

HEADER2

print '
\vspace{10pt}

';

print $qzt->{'instructions'};

print '
\vspace{5pt}
';

print '
\begin{questions}
';

my @problems = @{$qzt->{problems}};

unless (@problems) {
	die "This test has no problems, aborting";
}

for (my $i = 0; $i < @problems; $i++) {
	my $qzp = parse_file($problems[$i]);

	my $workspace = $qzp->{workspace};

	# Add a pagebreak between problems if requested
	if ($qzp eq '\pagebreak') {
		#print "\n\\pagebreak\n";  # DISABLED
		next;
	}

	print "\n";

	# Add Vim folds to make the .tex source easier to navigate.
	print "% {{{ Q" . ($i + 1) . "\n";

	print "\\begin{minipage}{\\textwidth}\n";
	print "\n";

	print "\\question ";
	#print "$n.)  ";

	# print the question
	# And also fix the }}} in equations which conflict with Vim folds
	my $tmp = $qzp->{question};	
	$tmp =~ s/}}}/} } }/g;
	print $tmp;

	if ($printanswers) {
		# leave out the work space if answers are being included
	} elsif ($workspace ne "" and $workspace ne '0'
				and $workspace ne 'wholepage') {
		print "\n";
		print '\vspace*{' . $workspace . '}';
		print "\n";
	}

	print "\n\\end{minipage}\n";

	# If the problem workspace needs the 'wholepage' 
	# do this by adding a pagebreak.
	# If a preceeding page break is desired this can be accomplished
	# by using \pagebreak as a problem in the test definition (see above).
	if ($workspace eq 'wholepage') {
		print '\pagebreak' . "\n";
	}

	print "\n";

	# The answer is always in the .tex output, but it
	# can be configured in that file whether to display
	# them or not.
	print "% {{{ solution\n";
	print "\\begin{solution}\n";

	# print the anser
	# And also fix the }}} in equations which conflict with Vim folds
	my $tmp = $qzp->{answer};	
	$tmp =~ s/}}}/} } }/g;
	print $tmp;

	print "\n\\end{solution}\n";

	print "% }}}\n";  # END solution fold
	print "% }}}\n";  # END question fold
}

print '
\end{questions}

\end{document}
';

}
# }}}

<?php echo "<?xml version='1.0' encoding='utf-8'?> <!-- -*- xml -*- -->\n" ?>

<?php echo
"<!-- This file was generated using: php user.xml.php
Do not edit this file because changes will be overwritten 
the next time it is generated.
Instead edit: usage.xml.php
-->\n"
; ?>

<chapter>
<title>Usage</title>

<!-- {{{ Installation -->
<section>
  <title>Installation</title>

<para>
  The following describes in general how to install this package
  in to a user directory.
  File and directory names may need to be altered slightly depending
  on your installation.
</para>

<para>
  First the distribution must be unpacked and placed
  some where in the home directory.
</para>

<programlisting><![CDATA[
jeri@bishop ~$ ls QuizMaker.tar.gz
QuizMaker.tar.gz
jeri@bishop ~$ tar -xvf QuizMaker.tar.gz
jeri@bishop ~$ ls QuizMaker/
bin  dev  doc  lib  TODO
jeri@bishop ~$ ls QuizMaker/
]]>
</programlisting>

<para>
  This system has a Perl 5 module which is necessary
  to run the utility functions (qzm-load_file, qzm-preview_problem, etc).
  Shown below is how to create a locally accessable Perl 5
  library directory to link to these files.
</para>

<programlisting><![CDATA[
jeri@bishop ~$ mkdir -p lib/perl5
jeri@bishop ~$ cd lib/perl5
jeri@bishop perl5$ ln -s ~/QuizMaker/lib/perl5/QuizMaker.pm .
jeri@bishop perl5$ ln -s ~/QuizMaker/lib/perl5/QuizMaker .
jeri@bishop perl5$ cd
jeri@bishop ~$ # make sure PERL5LIB is not already defined
jeri@bishop ~$ env | grep PERL5
jeri@bishop ~$ # blank output OK
jeri@bishop ~$ export PERL5LIB="$HOME/lib/perl5"
jeri@bishop ~$ # place the above command in .bashrc to execute automatically
jeri@bishop ~$ env | grep PERL5
PERL5LIB=/home/jeri/lib/perl5
jeri@bishop ~$ # now it is defined correctly
]]>
</programlisting>

<para>
  Once the above is successfully completed it should be possible to
  run the qzm-* functions in QuizMaker/bin.
</para>

<para>
  In order for the utility functions to be accessed the QuizMaker bin
  must be added to your PATH.  It should look something like below.
  If it doesn't the PATH must be configured (usually in your .bashrc
  like how PERL5LIB was configured).
</para>

<programlisting><![CDATA[
jeri@bishop ~$ env | grep PATH
...
PATH=/usr/local/bin:/usr/bin:/bin:/home/jeri/QuizMaker/bin
...
]]>
</programlisting>

</section>
<!-- }}} -->

<!-- {{{ Creating Problems -->
<section>
  <title>Creating Problems</title>

<para>
  Each problem is created one at a time.
  It is likely a group of similar problems will be created during
  one session and will have similar tags but they will each remain
  independent of each other.
</para>

<para>
  To create a problem the following steps must be performed:
  <itemizedlist>
    <listitem><para>define the question and answer using LaTeX</para></listitem>
    <listitem><para>choose tags</para></listitem>
    <listitem><para>specify how many blank lines are needed to
    answering the question</para></listitem>
    <listitem><para>specifiy the amount of time it should take to answer the problem</para></listitem>
    <listitem><para>define a unique identifier (usually a time stamp or date)</para></listitem>
  </itemizedlist>
</para>

<section id="sec:creating_problems">
  <title>Creating Problems in Perl</title>

  <para>
    Shown below (<xref linkend="fig:perl_skel"/>) is the
      <emphasis>skeleton</emphasis> (template) problem definition file.
  </para>

  <figure id="fig:perl_skel">
    <title>skeleton problem definition in Perl</title>
    <mediaobject>

      <textobject>
<programlisting><![CDATA[
<?php system("cat ../examples/problems/skel.pl"); ?>
]]>
</programlisting>
</textobject>
<caption><para></para></caption>
</mediaobject>
</figure>

<para>
  Once a problem is created it should be previewed to make sure
  it looks correct when rendered (See <xref linkend="fig:problem_preview"/>).
</para>

<figure id="fig:problem_preview">
  <title>Previewing a problem</title>
  <mediaobject>
  <textobject>
<programlisting><![CDATA[
user$ qzm-preview.pl | rubber-pipe > tmp.dvi
user$ kdvi tmp.dvi
]]></programlisting>
</textobject>
<caption>
  <para>Example of commands to preview a problem.
    Other commands that process LaTeX and view dvi may work as well.</para>
</caption>
</mediaobject>
</figure>

<figure><title>Problem Preview</title>
<mediaobject>
  <imageobject>  
    <imagedata fileref="skel-problem.png" format="PNG"/>
  </imageobject>
  <caption>
    <para>A preview of the skel problem.</para>
  </caption>
</mediaobject>
</figure>


</section>

</section>
<!-- }}} -->

<section id="sec:adding_problems">
  <title>Adding Problems (to the database)</title>

<para>
  Once a problem has been created and the output has been previewed (<xref linkend="sec:creating_problems"/>) it can be added to the database.
</para>

<figure id="fig:add_problem">
  <title>Adding a problem.</title>
  <mediaobject>
  <textobject>
<programlisting><![CDATA[
user$ qzm-load.pl <file> [<file2> ...]
]]></programlisting>
</textobject>
<caption>
  <para>Usage example of qzm-load.pl used to load a problem.</para>
</caption>
</mediaobject>
</figure>

<para>
  One problem that may arise is when the user attempts to add a file more
  than once.  If a unique identifer (UUID) has been identified for the
  problem it will not be added again.
  Otherwise the sytesm will assume the problem is new and add it like normal.
</para>

</section>

<!-- {{{ Creating Tests -->
<section>
  <title>Creating Tests</title>

<para>
  Once a database of problems is available tests can be created by selecting
  from these problems.
</para>

<para>
  The most general means of selection is through tags.
  The more tags that are selected the more restrictive will be the selection
  and the fewer number of problems that will match this criteriea.
  The fewer tags that are select is the opposite (less restrictive).
</para>

<para>
  Once a rough set of problems has been chosen the test can be previewed.
  Problems can be removed, their sequence changed and their assigned points
  varied.
  A summary of the test (total points) can be viewed.
</para>

<para>
  When the set of problems is finalized it can be locked to prevent any further
  alteration.
  From this template instances of the test can be taken.
  Each instance is unique based on the date it was taken and the user who
  took the test.
  This template will always be stored which means that it is possible to take
  the exact same test from the past any time in the future.
</para>

</section>
<!-- }}} -->

<!-- {{{ Scoring Tests -->
<section>
  <title>Scoring Tests</title>

<para>
  Scoring tests involves scanning through a completed test and determining
  whether the answer is right or wrong.
  The degree to which it is right or wrong is defined by a number of points.
  Completely right gets the maximum number of points whereas completely wrong
  gets no points.
  The amount of points each problem is worth is defined on a per test basis.
  The score of a problem can not exceed the maximum number of points defined.
</para>

</section>
<!-- }}} -->

<section>
  <title>Analyzing Test Performance</title>

<para>
  Once a test is scored it can be analyzed.
  For a single test the problems and their score can be viewed.
  The score can also be grouped by tags to see if there is any correlation.
  If there is signs of poor understanding correlated to specific tags
  a new test could be created that is weighted heavier with these tags.
</para>

<para id="recursive_improvement">
  This process of testing and then analyzing the performance specific to tags
  has the potential to find the root cause of a students lack of performance.
  Consider the following situation.
  A test is taken and it is found that performance was poor on problems tagged
  with 'integration'.
  Another test is taken that is weighted heavier with 'integration' and it
  is found that performance was poor on problems tagged with 'partial fractions'.
  Another test is taken that is weighted heavier with 'partial fractions' and
  it is found that performance is poor with 'polynomial long division'.
  This process of isolating tags to focus on poorly performing subjects
  could be quite useful. 
</para>

</section>

<section>
  <title>Interesting Side Effects</title>

<para>
There are several interesting side effects of the system that were not
designed in intentionally.
</para>

<para>
Because problems are defined by tags it is easy to discriminate between
groups of problems.
Two seperate subjects could be easily seperated using tags such as 'anthropology'
and 'mathematics'.
But it is also possible to merge these groups of problems togther in to
one test.
A test involving math, history, programming and art is something you would
never get in a standard class.
Whether this has much use other than being a novelty remains to be seen.
</para>

<para>
The possiblity of easily sharing problems is an interesting variation
with no current similarity.
Students in a class usually all have access to a common set of questions in a book.
But sharing of answers is seldom done and when the problems are on paper
it is cubersome to do so.
Of course it is beneficial for the student to struggle on an answer before
it is given to them but it may also be beneficial to see how others solve problems.
</para>

<para>
    A standard textbook will have a few detailed examples in the chapter.
    At the end of the chapter there will be a large number of exercises.
    And at the back of the book there will be answers to the odd questions.
    One difficulty with this situation is that the answers do not show
    all the steps.
    If they did the book would be many magnitudes larger so it makes sense
    why it is done this way.
    Using the QuizMaker system all problems are stored electronically so
    their is no comparable size constraints.
    The problems are stored in small text files and their size compared to
    the amount of disk space is miniscule.
    Every problem can be stored along with a complete and detailed solution.
</para>

<para>
    There is a certain method one performs while solving exercises.
    Attempt the exercise, review the notes if there is a difficulty,
    and check the answer at the end.
    This is drastically different than a test taking situation.
    A set of problems are given, there are no notes (except maybe a cheat sheet),
    you cannot check your answer, and there is a limited time period.
    The drastic differences between these two situations can help explain
    why taking tests can be very difficult.
    The QuizMaker system allows a student to create tests for himself
    that simulate test taking conditions more closely.
</para>

<para>
    Another difference between studying and taking tests is the
    order of problems.
    During studying a single section will be studied at a time
    and many similar problems will be solved.
    But in a test there will be problems from all the studied sections. 
    Obviously it would be difficult to learn a subject by studying all
    sections at once because some sections depend on knowledge gained from
    a previous section.
    But after studying a suction it would be worthwhile to test your self
    on not only that section but all the previous sections.
    This could be easily accomplished using the QuizMaker system.
</para>

</section>


</chapter>

<!-- vim:syntax=xml
-->


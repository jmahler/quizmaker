#!/usr/bin/perl
use strict;
use DBI;

use List::MoreUtils qw(uniq);

use QuizMaker;

#
# qzm-make_test.pl
#
# A shell for building a test.
#

my $CAUTIOUS = 1;
my $VERBOSE = 1;
my $DEBUG = 1;

my $qzm = QuizMaker->new()
    or exit 1;;
my $dbh;

my $selected_test = '';
my $unk_cmd_msg = "unknown command";
my $cmd_line = "qzm";
my $last_test_id;

# main loop

while (1) {

	print "$cmd_line\$ ";
	my $cmd = <STDIN>;
	chomp($cmd);

	# switch <command>
	# {{{ help
	if ($cmd =~ /help/) {
print "
  ls                  # list all tests
  ls <test id>        # list a specific test
  tag                 # list tags

  create <test name>  # create a new test

  add <test id> <tag>[, <tag 2>, ...]
                      # add all problems with all the tags
  padd <test id> <tag>[, <tag 2>, ...]
                      # like 'add' but just show what would be done
  ladd <test id> <limit> <tag>[, <tag 2>, ...]
                      # like 'add' but limit the maximum
  lpadd <test id> <limit> <tag>[, <tag 2>, ...]
                      # like 'ladd' but just show what would be done

  # <test id> set on last 'ls'
  #   or it can be specified again.
  ls [<test id>]      # list questions on a test


  finish <test id>    # Finish editing a test and prevent further changes.
                      # This must be performed before a test can be taken.

  help                # This screen.
  quit                # quit
  q
  exit
" 
	# }}}
	# {{{ ls <specific test>
	} elsif ($cmd=~ /^ls[\s]+([\S]+)$/) {

		my $new_test_id = $+;
		chomp($new_test_id);

		if (is_valid_test_id($dbh, $new_test_id)) {
			$last_test_id = $new_test_id;
		} else {
			print "Invalid test_id: '$new_test_id'\n";
			next;
		}

		# list a specific test

		my $test_data_ref = get_test_data($dbh, $last_test_id);
		my %test_data = %$test_data_ref;

my ($total, $num_corr);
my ($tag, $pcnt_right, $pcnt_total, $par_time, $act_time);
format LIST_TEST =
@<<<<<<<<<<<<<<<<...  @<<<<<<  @<<<<<<<<   @<<<<<<<<...   @<<<<<<<  @<<<<<<<
$tag, $total, $pcnt_total, $pcnt_right, $par_time, $act_time
.

		my $ofh = select(STDOUT);
		$~ = "LIST_TEST";
		print STDOUT "Total Problems: ", $test_data{count}, "\n";
		$num_corr = (0 == $test_data{num_corr}) ? 0 : (($test_data{count} / $test_data{num_corr})*100);

		print STDOUT "(%) Correct: ", $num_corr, "\n";
		
		$tag = 'tag';
		$total = 'total';
		$pcnt_total = '(%) total';
		$pcnt_right = '(%) right';
		$par_time = 'par_time';
		$act_time = 'act_time';
		write();
		$tag =~ s/./-/g;
		$total =~ s/./-/g;
		$pcnt_total =~ s/./-/g;
		$pcnt_right =~ s/./-/g;
		$par_time =~ s/./-/g;
		$act_time =~ s/./-/g;
		write();

		foreach my $_tag (keys %{$test_data{tags}}) {

			$tag = $_tag;
			$total = $test_data{tags}{$tag}{total};
			$num_corr = $test_data{tags}{$tag}{num_corr};
			$act_time = $test_data{tags}{$tag}{act_time};
			$par_time = $test_data{tags}{$tag}{par_time};

			if ($total > 0) {
				$pcnt_right = (($num_corr / $total) * 100);
			} else {
				$pcnt_right = 0;
			}

			if ($test_data{count} > 0) {
				$pcnt_total = (($total / $test_data{count}) * 100);
			} else {
				$pcnt_total = 0;
			}

			write();
		}

		$~ = $ofh;

    # }}}
    # {{{ tests   (all tests)
	} elsif ($cmd=~ /^tests[\s]*$/) {

        my @tests = $qzm->get_tests();

        my $num_tests = @tests;


        my ($test_id, $dsc, $finished, $create_date);

format LIST_TESTS =
@<<<<  @<<<<<<<<<<<<<<<<<<...  @<<<<<<<...  @<<<<<<<<<<<<<<<<<<<<
$test_id, $dsc, $finished, $create_date
.

		my $ofh = select(STDOUT);
		$~ = "LIST_TESTS";

		# display header
		$test_id = 'id';
		$dsc = 'description        ';
		$finished = 'finished';
		$create_date = 'create date';
		write();

        # underline header
		$test_id =~ s/./-/g;
		$dsc =~ s/./-/g;
		$finished =~ s/./-/g;
		$create_date =~ s/./-/g;
		write();

		my $print_fn = sub {
				my ($test) = @_;
				$test_id = $test->{test_id};	
				$dsc = $test->{dsc};	
				$finished = $test->{finished};	
				$create_date = $test->{create_date};	
				write();
		};

		foreach my $finished_else ((1, 0)) {
			if ($finished_else) {
				print STDOUT "  FINISHED (readonly)\n";	
			} else {
				print STDOUT "  UNFINISHED\n";
			}

			foreach my $test (@tests) {

				if ($test->{finished} and $finished_else) {
					$print_fn->($test);
				} elsif (! $test->{finished} and ! $finished_else) {
					$print_fn->($test);
				}
			}
		}

		$~ = $ofh;

		print "($num_tests tests)\n";
	# }}}
	# {{{ create <test name>
	} elsif ($cmd =~ /^create/) {

        # extract the description from the command string
		my $dsc = $cmd;
		$dsc =~ s/^create[\s]*//;
		
        $qzm->create_test($dsc);
	# }}}
	# {{{ delete <test id>
	} elsif ($cmd =~ /^delete/) {

        # extract the test_id from the command string
		my $test_id = $cmd;
		$test_id =~ s/^delete[\s]*//;
		
        $qzm->delete_test($test_id);
	# }}}
	# {{{ finish <test id>
	} elsif ($cmd =~ /finish/) {

		my $test_id = $cmd;
		$test_id =~ s/^finish[\s]*//;
        chomp($test_id);

        $qzm->finish_test($test_id);

	# }}}
	# {{{ add
	} elsif ($cmd =~ /^add/ or $cmd =~ /^padd/ or $cmd =~ /^ladd/ or $cmd =~ /^lpadd/) {
		# padd - "pretend add" or "no act"
		# add <tag>
		# ladd <limit> <tag1>, [<tag2>, <tag3>, ...]

		unless (defined $last_test_id) {
			print "You must select a test_id before using 'add'.\n";
			next;
		}
		my $test_id = $last_test_id;

		my $no_act = ($cmd =~/^padd/ or $cmd =~ /^lpadd/) ? 1 : 0;

		my $limit = 10000;
		my @tags;
		my $tag_rest;

		my $x = $cmd;
		$x =~ s/^.*add[\s]*//;

		if ($cmd =~ /^l/) {
			$x =~ /[\s]*([\d]+)[\s]+(.*)/;

			($limit, $tag_rest) = ($1, $2);
			
		} else {
			$tag_rest = $x;
		}

		$tag_rest =~ s/[\s]$//;
		@tags = split /,[\s]*/, $tag_rest;
		
		#print "tag, limit: $tag, $limit\n";


		my $get_problems_sql =
			"SELECT DISTINCT problem_id FROM ProblemTags AS PT1 WHERE\n";
			my $first = 1;
			map {
				if ($first) {
					# skip WHERE
					$first = 0;
					$get_problems_sql .= "        ";
				} else {
					$get_problems_sql .= "    AND ";
				}	
				$get_problems_sql .= "? IN (SELECT tag FROM ProblemTags AS PT2 WHERE problem_id = PT1.problem_id)\n";
			} @tags;

			# exclude the questions already in the test
			$get_problems_sql .=
				"    AND problem_id NOT IN\n" .
				"     (SELECT problem_id FROM TestProblems WHERE test_id = ?) ;";

#print "$get_problems_sql\n";
#next;

		my $max_problem_num_sql =
			"SELECT max(problem_num) FROM TestProblems WHERE
				test_id = ? ;";
		my $problem_num;

		my $add_problem_sql =
			"INSERT INTO TestProblems (test_id, problem_id, problem_num)
				VALUES (?, ?, ?) ;";

		my $get_problems_sth = $dbh->prepare($get_problems_sql);
		$get_problems_sth->execute(@tags, $test_id);

		my $all_problems_ref = $get_problems_sth->fetchall_arrayref;
		my $num_problems = @$all_problems_ref;

		my $problem_num_sth = $dbh->prepare($max_problem_num_sql);
		$problem_num_sth->execute($test_id);
		$problem_num = ($problem_num_sth->fetchrow_array())[0];

		my $add_problem_sth = $dbh->prepare($add_problem_sql);

		print "found $num_problems problems\n";
		my $n_limit = 0;

		my @all_problems = @$all_problems_ref;
		fisher_yates_shuffle(\@all_problems);

		foreach my $problem_id_ref (@all_problems) {
			my $problem_id = $problem_id_ref->[0];
			$problem_num++;

			if ($no_act) {
				print "  INSERT $problem_id -> $problem_num\n";
			} else {
				$add_problem_sth->execute($test_id, $problem_id, $problem_num);
			}
			$n_limit++;

			last if ($n_limit >= $limit);
		}

	# }}}
	# {{{ tags - list available tags
	} elsif ($cmd =~ /^tags?[\s]*$/) {
        my @tags = $qzm->get_tags();

        my ($tag, $count);

format TAG_LIST =
@<<<<<<<<<<<<<<<<<<<<<<<<<...  @<<<<<<<
$tag, $count
.

		my $ofh = select(STDOUT);
		$~ = "TAG_LIST";

        # header
		$tag = 'tag      ';
		$count = 'count';
		write();

        # underline header
		$tag =~ s/./-/g;
		$count =~ s/./-/g;
		write();

        foreach my $_tag (@tags) {
            $tag = $_tag->{tag};
            $count = $_tag->{count};

			write();	
		}

		$~ = $ofh;

	# }}}
	# {{{ done, quit
	} elsif ($cmd =~ /^done$/ or $cmd =~ /^quit$/ or $cmd =~ /^q$/) {
		last;
	# }}}
	# {{{ (blank line)
	} elsif ($cmd =~ /^[\s]*$/) {
	# }}}
	# {{{ (unknown command)
	} else {
		print "Unknown command, do you need to 'select' a test first?\n";
	}
	# }}}

}

# {{{ sub fisher_yates_shuffle
# Taken from Perl Cookbook [Pg. 121]
sub fisher_yates_shuffle {
	my $array = shift;
	my $i;
	my $n = @$array;
	for ($i = $n - 1; $i > 0; --$i ) {
		my $j = int rand ($i + 1);
		next if $i == $j;

		my $x = $array->[$i];
		$array->[$i] = $array->[$j];
		$array->[$j] = $x;

		#@$array->[$i,$j] = @$array[$j,$i];
		#@$array[$i,$j] = @$array[$j,$i];
	}
}
# }}}
